---
layout: post
title:  "spring mvc -1"
date:  2016-12-31 10:20:00 +0800
categories: spring
tags: spring
keywords: spring,web1992
---


spring mvc
---

源码分析spring mvc 笔记

> Spring 源码的版本是：v4.1.1.RELEASE

<!--more-->

一段经典的spring mvc 代码

```java

    @Controller
    public class IndexController {
      
        @RequestMapping(value = {" ", "/"})
        @ResponseBody
        public String index(@RequestParam(required = false) boolean test) {
    
            return "200";
        }
    
    }

```

- 1 [@Controller  是如何被加载的](#v1)
- 2 [@RequestMapping  是如何映射成URL的](#v2)
- 3 [@RequestParam  的参数是如何注入的]()
- 4 [@ResponseBody  是如何处理的]()
- 5 [注解的类，在被加载之后，存储在了哪里?]()

#### <a name="v1">1 @Controller  是如何加载这个注解的</a>

思路：查看spring 源代码，查看@Controller 注解的描述


`This annotation serves as a specialization of {@link Component @Component},*

 allowing for implementation classes to be autodetected through classpath scanning.`
 
`@see org.springframework.context.annotation.ClassPathBeanDefinitionScanner`


**发现了一个关键点 `classpath scanning`（从classpath去扫描有这个注解的类**

**具体的扫描实现是`ClassPathBeanDefinitionScanner`这个类中存在`doScan` 方法** 

查询这个方法被调用的地方

![](https://thumbnail0.baidupcs.com/thumbnail/788803f2f64092ef43bbdc39ce15388c?fid=3793276487-250528-22703699854444&time=1483408800&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-AATsygOmEvYpTH%2FkCR7KQY6GzwU%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=56621177185574247&dp-callid=0&size=c710_u400&quality=100)

**发现有三个类引用了这个方法**

- ConfigurationClassPostProcessor
- ClassPathBeanDefinitionScanner
- ComponentScanBeanDefinitionParser


**分别查看这三个类的描述**

- 1)ClassPathBeanDefinitionScanner

`A bean definition scanner that detects bean candidates on the classpath` 扫描加载classpath路径下面的类

会扫描含有下面注解的类(等等其他注解,具体可查询源码文档描述)

```java
org.springframework.stereotype.Component
org.springframework.stereotype.Repository
org.springframework.stereotype.Service
org.springframework.stereotype.Controller
```

- 2) ComponentScanAnnotationParser

`Parser for the @{@link ComponentScan} annotation.` 扫描加载classpath路径下面的类

这个类底层依然是使用 ClassPathBeanDefinitionScanner 进行类的扫描加载

- 3) ComponentScanBeanDefinitionParser

`Parser for the {@code <context:component-scan/>} element.`

这个类底层也是使用 ClassPathBeanDefinitionScanner 进行类的扫描加载

>**这里我们知道了spring使用三个类(这里叫做BeanScan吧)，分别取扫描使用注解和xml修饰类，把这些类放入 spring 的Bean 容器中**

>**xml中的类，最终也是交给了 ClassPathBeanDefinitionScanner 进行扫描加载的，其他的Bean加载器，只不过是对其进行了包装**


>看一个xml代码片段

```xml
class="cn.web1992.utils.AppConfig"

base-package="cn.web1992.controller"
```

这些xml中的配置，本质也就是类的路径，用`ClassPathBeanDefinitionScanner`加载也是合理的设计。


>总结：

**spring 中对于Bean的加载，主要是`ClassPathBeanDefinitionScanner`这个类负责的。**

>思考:

_这三个BeanScan的先后顺序是怎么样的？_

_被加载后的Bean存储在哪里了？（交给谁去管理了？）_


#### <a name="v2">2 @RequestMapping  是如何映射成URL的</a>


先从RequestMapping 注解的用法：简单的理解，把一个控制器中的一个方法映射为URL。


比如：

```java
    @RequestMapping(value = {"/index2"})
    @ResponseBody
    public String index2() {
        return "index2";
    }
```

这个例子中把 /index2 这个URI 路径，映射为 index2 方法。

如果你访问 http://127.0.0.1:8080/index2 就可以调用到 index2 这个方法。

这里主要思考，这个是怎么完成的。


那么Spring MVC 是如何实现的呢？


在之前的一篇[文章](https://web1992.cn/blog/spring/2016/09/27/spring-init/)中提到，Spring MVC 中`DispatcherServlet`是负责请求转发的，那么这里就从这里入手去探寻他是如何实现的。


从DispatcherServlet 中找到了这个一个方法 DispatcherServlet#getHandler，该方法返回的是一个 HandlerExecutionChain 对象，

DispatcherServlet#getHandler 主要从 BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping中获取HandlerExecutionChain

DispatcherServlet在初始化的时候，会进行 `private List<HandlerMapping> handlerMappings` 属性的初始化操作。



DispatcherServlet.properties的配置如下：

```
org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping
```

DefaultAnnotationHandlerMapping 集成了 AbstractUrlHandlerMapping类。

AbstractUrlHandlerMapping#registerHandler 提供了注册方法









